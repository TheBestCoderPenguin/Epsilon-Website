<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Formation Lines ‚Äî Heart ‚Üí üôÇ ‚Üí üôÅ ‚Üí ‚óã</title>
<style>
  :root{
    --sky1:#aee1ff; --sky2:#eaf6ff;
    --cloud:#fff;
  }
  html,body{height:100%;margin:0}
  body{background:linear-gradient(var(--sky1),var(--sky2) 60%);overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .stage{position:relative;width:100vw;height:100vh}
  /* Clouds */
  .cloud{position:absolute;background:var(--cloud);border-radius:100vmax;filter:drop-shadow(0 2px 6px rgba(0,0,0,.08));opacity:.95}
  .cloud:before,.cloud:after{content:"";position:absolute;background:var(--cloud);border-radius:100vmax}
  .cloud:before{inset:-25% auto auto -18%;width:70%;height:90%}
  .cloud:after{inset:10% -20% auto auto;width:85%;height:70%}
  @keyframes driftL{from{transform:translateX(110vw)}to{transform:translateX(-120vw)}}
  @keyframes driftR{from{transform:translateX(-120vw)}to{transform:translateX(110vw)}}
  .c{height:12vmin;width:22vmin}
  .c1{top:10vh;animation:driftL 70s linear infinite}
  .c2{top:18vh;animation:driftR 90s linear infinite;opacity:.9}
  .c3{top:26vh;animation:driftL 80s linear infinite;opacity:.88}
  .c4{top:34vh;animation:driftR 95s linear infinite;opacity:.86}
  .c5{top:14vh;animation:driftL 85s linear infinite;opacity:.9}
  .c6{top:22vh;animation:driftR 75s linear infinite;opacity:.9}
  /* Planes */
  .plane{position:absolute;transform:translate(-50%,-50%);font-size:6vmin;will-change:transform}
  /* Subtle vignette */
  .v{position:absolute;inset:0;pointer-events:none;box-shadow:inset 0 0 240px rgba(0,0,0,.18)}
  .hud{position:absolute;left:1rem;bottom:1rem;font-size:.95rem;color:#124;opacity:.6}
</style>
</head>
<body>
<div class="stage" id="stage">
  <!-- clouds (more, but not too many) -->
  <div class="cloud c c1" style="left:-30vmin"></div>
  <div class="cloud c c2" style="left:-20vmin"></div>
  <div class="cloud c c3" style="left:-40vmin"></div>
  <div class="cloud c c4" style="left:-10vmin"></div>
  <div class="cloud c c5" style="left:-25vmin"></div>
  <div class="cloud c c6" style="left:-35vmin"></div>

  <!-- smoke layer -->
  <canvas id="smoke"></canvas>

  <!-- planes (4) -->
  <div class="plane" id="A">üõ©Ô∏è</div>
  <div class="plane" id="B">üõ©Ô∏è</div>
  <div class="plane" id="C">üõ©Ô∏è</div>
  <div class="plane" id="D">üõ©Ô∏è</div>

  <div class="v"></div>
  <div class="hud" id="hud">Heart ‚Üí Smiley ‚Üí Sad ‚Üí Big Circle ‚Ä¢ lines auto-clear between breaks</div>
</div>

<script>
/* === base === */
const stage = document.getElementById('stage');
const smoke = document.getElementById('smoke');
const ctx = smoke.getContext('2d');
let W=stage.clientWidth, H=stage.clientHeight;
function resize(){ W=stage.clientWidth; H=stage.clientHeight; smoke.width=W; smoke.height=H; }
addEventListener('resize', resize); resize();

const blue = 'rgba(40,110,255,0.95)';   // the blue you liked
const planes = {
  A:{el:document.getElementById('A'), x:W*.5, y:H*.8, tx:W*.5, ty:H*.8, h:0, lastx:W*.5, lasty:H*.8, scale:1, color:blue},
  B:{el:document.getElementById('B'), x:W*.48, y:H*.82, tx:W*.48, ty:H*.82, h:0, lastx:W*.48, lasty:H*.82, scale:1, color:blue},
  C:{el:document.getElementById('C'), x:W*.52, y:H*.82, tx:W*.52, ty:H*.82, h:0, lastx:W*.52, lasty:H*.82, scale:1, color:blue},
  D:{el:document.getElementById('D'), x:W*.46, y:H*.84, tx:W*.46, ty:H*.84, h:0, lastx:W*.46, lasty:H*.84, scale:1, color:blue},
};
const IDs = ['A','B','C','D'];

function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function lerp(a,b,t){return a+(b-a)*t}
function ease(t){return t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2}
function ang(ax,ay,bx,by){return Math.atan2(by-ay, bx-ax)}
function faceToTravel(p){ const dx=p.x-p.lastx, dy=p.y-p.lasty; if(dx*dx+dy*dy>1e-4){ p.h = Math.atan2(dy,dx);} }

/* === drawing / smoke === */
function fadeTrails(alpha=0.06){
  ctx.fillStyle = `rgba(255,255,255,${alpha})`;
  ctx.fillRect(0,0,W,H);
}
function hardClear(){ ctx.clearRect(0,0,W,H); }

/* === helpers === */
function placeV(cx,cy,sp){
  const offs=[[0,0],[-sp, sp*.9],[ sp, sp*.9],[-sp*1.8, sp*1.8]];
  IDs.forEach((id,i)=>{ planes[id].tx=cx+offs[i][0]; planes[id].ty=cy+offs[i][1]; });
}
function moveAllToward(dt){
  const k=9; // follow strength
  for(const id of IDs){
    const p=planes[id];
    p.lastx = p.x; p.lasty = p.y;
    p.x += (p.tx - p.x) * clamp(k*dt,0,1);
    p.y += (p.ty - p.y) * clamp(k*dt,0,1);
    faceToTravel(p);
  }
}
function renderPlanes(){
  for(const id of IDs){
    const p=planes[id];
    // draw smoke line segment
    ctx.strokeStyle = p.color;
    ctx.lineWidth = Math.max(2, Math.min(W,H)*0.006);
    ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(p.lastx,p.lasty); ctx.lineTo(p.x,p.y); ctx.stroke();

    // emoji orientation (add 90¬∞ because plane emoji points up)
    const deg = (p.h*180/Math.PI)+90;
    p.el.style.transform = `translate(${p.x}px,${p.y}px) translate(-50%,-50%) rotate(${deg}deg) scale(${p.scale})`;
  }
}

/* === parametric shapes === */
// Heart (classic)
function heartXY(u, cx, cy, s){
  // u in [0..1] maps to Œ∏ in [0..2œÄ]
  const th = u * Math.PI*2;
  const x = 16*Math.pow(Math.sin(th),3);
  const y = 13*Math.cos(th)-5*Math.cos(2*th)-2*Math.cos(3*th)-Math.cos(4*th);
  return [cx + x*s, cy - y*s];
}
// Circle
function circleXY(u, cx, cy, R){
  const th = u*2*Math.PI;
  return [cx + Math.cos(th)*R, cy + Math.sin(th)*R];
}
// Arc (for smiles)
function arcXY(u, cx, cy, R, startDeg, endDeg){
  const th = (startDeg + (endDeg-startDeg)*u) * Math.PI/180;
  return [cx + Math.cos(th)*R, cy + Math.sin(th)*R];
}

/* === timeline segments === */
const segments=[];
function seg(dur, setup, update, cleanup){ segments.push({dur,setup,update,cleanup,init:false,t:0}) }

/* Intro: form a neat V mid-sky */
seg(2.2,
  ()=>{}, // setup
  (t)=>{
    const T=ease(t);
    placeV(lerp(W*.5,W*.5,T), lerp(H*.85,H*.60,T), Math.min(W,H)*0.07);
  },
  ()=>{ hardClear(); } // clear lines before first shape draw
);

/* 1) HEART ‚Äî all four trace the full heart, phased so it draws fast */
seg(4.0,
  ()=>{ /* center of heart */ },
  (t)=>{
    const cx=W*.5, cy=H*.48, s=Math.min(W,H)*0.01*2.4;
    const phases = {A:0, B:.25, C:.5, D:.75};
    for(const id of IDs){
      const u = (t + phases[id]) % 1;
      const [x,y]=heartXY(u, cx, cy, s);
      planes[id].tx=x; planes[id].ty=y;
    }
  },
  ()=>{ hardClear(); } // wipe after heart
);

/* Regroup center briefly */
seg(1.2,
  ()=>{},
  (t)=>{
    const T=ease(t);
    placeV(W*.5, lerp(H*.58,H*.50,T), Math.min(W,H)*0.065);
  },
  ()=>{ hardClear(); } // make next face clean too
);

/* 2) SMILEY ‚Äî B&C draw eyes (small circles), A&D draw smile arc */
seg(4.0,
  ()=>{},
  (t)=>{
    // eyes
    const eyeR = Math.min(W,H)*0.03;
    const eyeY = H*0.38, eyeXoff = Math.min(W,H)*0.09;
    const lc=[W*.5-eyeXoff, eyeY], rc=[W*.5+eyeXoff, eyeY];

    // mouth (smile arc)
    const mouthR = Math.min(W,H)*0.16;
    const mc=[W*.5, H*0.52];
    // draw lower arc from 200¬∞ to -20¬∞ (i.e., 200 ‚Üí 340)
    const start=200, end=340;

    // time split: whole 4s looping, so just continuous
    const [Bx,By]=circleXY(t, lc[0], lc[1], eyeR);
    const [Cx,Cy]=circleXY((t+.5)%1, rc[0], rc[1], eyeR);

    const [Ax,Ay]=arcXY(t, mc[0], mc[1], mouthR, start, end);
    const [Dx,Dy]=arcXY((t+.5)%1, mc[0], mc[1], mouthR, start, end);

    Object.assign(planes.B,{tx:Bx,ty:By});
    Object.assign(planes.C,{tx:Cx,ty:Cy});
    Object.assign(planes.A,{tx:Ax,ty:Ay});
    Object.assign(planes.D,{tx:Dx,ty:Dy});
  },
  ()=>{ hardClear(); } // wipe after smile
);

/* 3) SAD FACE ‚Äî same eyes; mouth arc upside-down */
seg(4.0,
  ()=>{},
  (t)=>{
    // eyes
    const eyeR = Math.min(W,H)*0.03;
    const eyeY = H*0.38, eyeXoff = Math.min(W,H)*0.09;
    const lc=[W*.5-eyeXoff, eyeY], rc=[W*.5+eyeXoff, eyeY];

    // mouth (sad arc) upper arc from 160¬∞ to 20¬∞
    const mouthR = Math.min(W,H)*0.16;
    const mc=[W*.5, H*0.58];
    const start=160, end=20;

    const [Bx,By]=circleXY(t, lc[0], lc[1], eyeR);
    const [Cx,Cy]=circleXY((t+.5)%1, rc[0], rc[1], eyeR);

    const [Ax,Ay]=arcXY(t, mc[0], mc[1], mouthR, start, end);
    const [Dx,Dy]=arcXY((t+.5)%1, mc[0], mc[1], mouthR, start, end);

    Object.assign(planes.B,{tx:Bx,ty:By});
    Object.assign(planes.C,{tx:Cx,ty:Cy});
    Object.assign(planes.A,{tx:Ax,ty:Ay});
    Object.assign(planes.D,{tx:Dx,ty:Dy});
  },
  ()=>{ hardClear(); } // wipe after sad
);

/* 4) BIG CIRCLE ‚Äî all four chase each other on a huge ring */
seg(5.0,
  ()=>{},
  (t)=>{
    const R = Math.min(W,H)*0.28;
    const cx=W*.5, cy=H*.50;
    const phases={A:0,B:.25,C:.5,D:.75};
    for(const id of IDs){
      const [x,y]=circleXY((t+phases[id])%1, cx, cy, R);
      planes[id].tx=x; planes[id].ty=y;
    }
  },
  ()=>{ /* final: keep trails or clear ‚Äî your call */ }
);

/* === animator === */
let idx=0, last=performance.now();
function tick(now){
  const dt=(now-last)/1000; last=now;

  // segment handling
  if(idx>=segments.length){ idx=0; } // loop whole show
  const s=segments[idx];
  if(!s.init){ s.init=true; s.t=0; if(s.setup) s.setup(); }
  s.t += dt;
  const t = clamp(s.t/s.dur,0,1);
  s.update(t);

  // physics & trails
  fadeTrails(0.06);       // continuous faint fade for silky tails
  moveAllToward(dt);
  renderPlanes();

  if(t>=1){
    if(s.cleanup) s.cleanup();  // hard clear between breaks when requested
    idx++; // next
  }
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
</script>
</body>
</html>
